# Описание
Консьюмер-либа предоставляет собой api (rust-библиотеку) для создания отдельных консьюмеров для нужд различных микросервисов.

Содержа в себе общую для всех существующих консьюмеров логику, она позволит:

- значительно сократить объёмы повторяющегося кода, а, значит, и время на его поддержку
- унифицировать интерфейсы и шаблоны проектирования консьюмеров
- внедрять новые фичи и исправлять баги быстрее и лучше (в конечных консьюмерах потребуется лишь
переход на новую версию библиотеки с возможными незначительными правками кода)
- избавиться от legacy-кода

# Фичи/Фиксы
## Общая логика консьюмера
Получение сырых данных из blockchain updates, их парсинг и сохранение в БД.

### Предлагаемая реализация
Скелет консьюмер-либы аналогичен текущим `asset-search-consumer`, `data-service-consumer`, `state-consumer`, `transfers-consumer`. Два токио-таска, один читает апдейты по grpc и складывает их в канал, на принимающем конце другой читает и выполняет нужные `handle_*` и `extract_*`.


## Возможность выбора только нужных структур данных
Из blockchain updates приходит множество разных структур данных: блоки, ассеты, тикеры, транзакции и т.д.. В большинстве случаев необходима только часть из них, поэтому предлагается механизм экстракции и обработки нужных из всех возможных, представленных в либе.


Дефолтная логика обработки блоков в либе не всегда подходит конечному консьюмеру. Если требуется дополнительный код, можно написать свой экстрактор/хендлер для нужного типа, оверрайдящий дефолтное поведение.
Пример: экстракторы в пулах.

## Взаимодействие с БД
Каждый консьюмер имеет трейт `Repo` (`RepoOperations`), содержащий методы для работы с моделями, нужными конкретно этому консьюмеру. Вместо создания в либе одного `RepoOperations`, содержащего всевозможные методы для всех моделей (имплементация которого невозможна только для части моделей в конечном консьюмере), предлагается api из нескольких трейтов, содержащих методы только для конкретного типа. Пример:

```rust
pub trait RepoOperationsBlocks {
    fn get_prev_handled_height(&mut self) -> Result<Option<PrevHandledHeight>>;

    fn insert_blocks_or_microblocks(&mut self, blocks: &Vec<BlockMicroblock>) -> Result<Vec<i64>>;

    ...
}

pub trait RepoOperationsAssets {
    fn get_next_assets_uid(&mut self) -> Result<i64>;

    ...
}
```

## Оптимизация структуры БД
- хранить id объектов как bigint, а не varchar (Сергей)
- отказ от superseded_by?
- когда-то давно обсуждалась альтернатива текущей реализации скваша микроблоков (по обрывочным воспоминаниям) (возможно, уже не нужно)

## Предоставление единых DTO и моделей
Структуры данных консьюмер-либы публичны и рекомендованы к использованию во всех конечных консьюмерах.

Проблема: модели не будут `Insertable`/`Queryable`/... из-за жёсткой привязки моделей этими макросами к таблицам в реально существующем `schema.rs`, который отсутствует в либе. Возможные решения:
- таки генерировать `schema.rs` в либе, но возникает вопрос хранения/применения/добавления миграций рядом в либе и в конечном консьюмере одновременно
- переехать на `sqlx`

## Встроенный веб-интерфейс метрик
При создании инстанса консьюмера параллельно будет подниматься `MetricsWarpBuilder`, обслуживающий заданный набор метрик (включая метрику текущей высоты). Можно добавлять кастомные метрики.

## Ручка для роллбэка
На данный момент нет возможности роллбэкнуться до нужной высоты иначе, кроме как через вызов sql-процедуры.

### Предлагаемая реализация
Два варианта интерфейса:
- отдельный бинарь
- `--rollback-to=12345` в аргументах бинаря консьюмера

## Чтение конфигов
Опциональный модуль для чтения переменных окружения.

### Предлагаемая реализация
Интерфейс остаётся таким же, как и в большинстве сервисов биржи:
```rust
#[derive(Deserialize)]
struct RawConfig {/* */}

pub struct ConsumerConfig {/*..RawConfig*/}

impl ConsumerConfig {
    pub fn load() -> Result<ConsumerConfig, ConfigError> {/* */}
}
```

## Хуки
Консьюмеры, помимо основных задач, могут иметь дополнительный код, отрабатывающий в главном цикле. Для его регистрации предлагаются следующие виды хуков:
- `pre-handle-updates`
- `post-handle-updates`
- `pre-rollback`
- `post-rollback`

# sqlx
Возможна замена дизеля на sqlx, поскольку с усложнением sql-запросов в ORM возрастает когнитивная нагрузка, сообщения об ошибках типов дизеля становятся километровыми и малопонятными. Sqlx же позволяет писать на обычном sql, синтаксис которого проверяется в компайл-тайме с помощью макросов, а также десериализовывать результаты запроса сразу в нужные структуры вместо кортежей.

Для использования таких макросов в IDE или в `.env` должна быть поднята БД с миграциями и установлена энва `DATABASE_URL`.
